{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla/internals.mjs", "../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["const isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\r\nconst hasInitialValue = (atom) => \"init\" in atom;\r\nconst isActuallyWritableAtom = (atom) => !!atom.write;\r\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\r\nconst returnAtomValue = (atomState) => {\r\n  if (\"e\" in atomState) {\r\n    throw atomState.e;\r\n  }\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\r\n    throw new Error(\"[Bug] atom state is not initialized\");\r\n  }\r\n  return atomState.v;\r\n};\r\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\r\nconst isPendingPromise = (value) => {\r\n  var _a;\r\n  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\r\n};\r\nconst abortPromise = (promise) => {\r\n  const promiseState = promiseStateMap.get(promise);\r\n  if (promiseState == null ? void 0 : promiseState[0]) {\r\n    promiseState[0] = false;\r\n    promiseState[1].forEach((fn) => fn());\r\n  }\r\n};\r\nconst registerAbortHandler = (promise, abortHandler) => {\r\n  let promiseState = promiseStateMap.get(promise);\r\n  if (!promiseState) {\r\n    promiseState = [true, /* @__PURE__ */ new Set()];\r\n    promiseStateMap.set(promise, promiseState);\r\n    const settle = () => {\r\n      promiseState[0] = false;\r\n    };\r\n    promise.then(settle, settle);\r\n  }\r\n  promiseState[1].add(abortHandler);\r\n};\r\nconst isPromiseLike = (p) => typeof (p == null ? void 0 : p.then) === \"function\";\r\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\r\n  if (!dependencyAtomState.p.has(atom)) {\r\n    dependencyAtomState.p.add(atom);\r\n    promise.then(\r\n      () => {\r\n        dependencyAtomState.p.delete(atom);\r\n      },\r\n      () => {\r\n        dependencyAtomState.p.delete(atom);\r\n      }\r\n    );\r\n  }\r\n};\r\nconst setAtomStateValueOrPromise = (atom, valueOrPromise, ensureAtomState) => {\r\n  const atomState = ensureAtomState(atom);\r\n  const hasPrevValue = \"v\" in atomState;\r\n  const prevValue = atomState.v;\r\n  if (isPromiseLike(valueOrPromise)) {\r\n    for (const a of atomState.d.keys()) {\r\n      addPendingPromiseToDependency(atom, valueOrPromise, ensureAtomState(a));\r\n    }\r\n  }\r\n  atomState.v = valueOrPromise;\r\n  delete atomState.e;\r\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\r\n    ++atomState.n;\r\n    if (isPromiseLike(prevValue)) {\r\n      abortPromise(prevValue);\r\n    }\r\n  }\r\n};\r\nconst getMountedOrPendingDependents = (atom, atomState, mountedMap) => {\r\n  var _a;\r\n  const dependents = /* @__PURE__ */ new Set();\r\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\r\n    if (mountedMap.has(a)) {\r\n      dependents.add(a);\r\n    }\r\n  }\r\n  for (const atomWithPendingPromise of atomState.p) {\r\n    dependents.add(atomWithPendingPromise);\r\n  }\r\n  return dependents;\r\n};\r\nconst createStoreHook = () => {\r\n  const callbacks = /* @__PURE__ */ new Set();\r\n  const notify = () => {\r\n    callbacks.forEach((fn) => fn());\r\n  };\r\n  notify.add = (fn) => {\r\n    callbacks.add(fn);\r\n    return () => {\r\n      callbacks.delete(fn);\r\n    };\r\n  };\r\n  return notify;\r\n};\r\nconst createStoreHookForAtoms = () => {\r\n  const all = {};\r\n  const callbacks = /* @__PURE__ */ new WeakMap();\r\n  const notify = (atom) => {\r\n    var _a, _b;\r\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\r\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\r\n  };\r\n  notify.add = (atom, fn) => {\r\n    const key = atom || all;\r\n    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);\r\n    fns.add(fn);\r\n    return () => {\r\n      fns == null ? void 0 : fns.delete(fn);\r\n      if (!fns.size) {\r\n        callbacks.delete(key);\r\n      }\r\n    };\r\n  };\r\n  return notify;\r\n};\r\nconst initializeStoreHooks = (storeHooks) => {\r\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\r\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\r\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\r\n  storeHooks.f || (storeHooks.f = createStoreHook());\r\n  return storeHooks;\r\n};\r\nconst BUILDING_BLOCKS = Symbol();\r\nconst getBuildingBlocks = (store) => store[BUILDING_BLOCKS];\r\nconst buildStore = (atomStateMap = /* @__PURE__ */ new WeakMap(), mountedMap = /* @__PURE__ */ new WeakMap(), invalidatedAtoms = /* @__PURE__ */ new WeakMap(), changedAtoms = /* @__PURE__ */ new Set(), mountCallbacks = /* @__PURE__ */ new Set(), unmountCallbacks = /* @__PURE__ */ new Set(), storeHooks = {}, atomRead = (atom, ...params) => atom.read(...params), atomWrite = (atom, ...params) => atom.write(...params), atomOnInit = (atom, store) => {\r\n  var _a;\r\n  return (_a = atom.unstable_onInit) == null ? void 0 : _a.call(atom, store);\r\n}, atomOnMount = (atom, setAtom) => {\r\n  var _a;\r\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\r\n}, ...buildingBlockFunctions) => {\r\n  const ensureAtomState = buildingBlockFunctions[0] || ((atom) => {\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\r\n      throw new Error(\"Atom is undefined or null\");\r\n    }\r\n    let atomState = atomStateMap.get(atom);\r\n    if (!atomState) {\r\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\r\n      atomStateMap.set(atom, atomState);\r\n      atomOnInit == null ? void 0 : atomOnInit(atom, store);\r\n    }\r\n    return atomState;\r\n  });\r\n  const flushCallbacks = buildingBlockFunctions[1] || (() => {\r\n    const errors = [];\r\n    const call = (fn) => {\r\n      try {\r\n        fn();\r\n      } catch (e) {\r\n        errors.push(e);\r\n      }\r\n    };\r\n    do {\r\n      if (storeHooks.f) {\r\n        call(storeHooks.f);\r\n      }\r\n      const callbacks = /* @__PURE__ */ new Set();\r\n      const add = callbacks.add.bind(callbacks);\r\n      changedAtoms.forEach((atom) => {\r\n        var _a;\r\n        return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\r\n      });\r\n      changedAtoms.clear();\r\n      unmountCallbacks.forEach(add);\r\n      unmountCallbacks.clear();\r\n      mountCallbacks.forEach(add);\r\n      mountCallbacks.clear();\r\n      callbacks.forEach(call);\r\n      if (changedAtoms.size) {\r\n        recomputeInvalidatedAtoms();\r\n      }\r\n    } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\r\n    if (errors.length) {\r\n      throw new AggregateError(errors);\r\n    }\r\n  });\r\n  const recomputeInvalidatedAtoms = buildingBlockFunctions[2] || (() => {\r\n    const topSortedReversed = [];\r\n    const visiting = /* @__PURE__ */ new WeakSet();\r\n    const visited = /* @__PURE__ */ new WeakSet();\r\n    const stack = Array.from(changedAtoms);\r\n    while (stack.length) {\r\n      const a = stack[stack.length - 1];\r\n      const aState = ensureAtomState(a);\r\n      if (visited.has(a)) {\r\n        stack.pop();\r\n        continue;\r\n      }\r\n      if (visiting.has(a)) {\r\n        if (invalidatedAtoms.get(a) === aState.n) {\r\n          topSortedReversed.push([a, aState]);\r\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\r\n          throw new Error(\"[Bug] invalidated atom exists\");\r\n        }\r\n        visited.add(a);\r\n        stack.pop();\r\n        continue;\r\n      }\r\n      visiting.add(a);\r\n      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\r\n        if (!visiting.has(d)) {\r\n          stack.push(d);\r\n        }\r\n      }\r\n    }\r\n    for (let i = topSortedReversed.length - 1; i >= 0; --i) {\r\n      const [a, aState] = topSortedReversed[i];\r\n      let hasChangedDeps = false;\r\n      for (const dep of aState.d.keys()) {\r\n        if (dep !== a && changedAtoms.has(dep)) {\r\n          hasChangedDeps = true;\r\n          break;\r\n        }\r\n      }\r\n      if (hasChangedDeps) {\r\n        readAtomState(a);\r\n        mountDependencies(a);\r\n      }\r\n      invalidatedAtoms.delete(a);\r\n    }\r\n  });\r\n  const readAtomState = buildingBlockFunctions[3] || ((atom) => {\r\n    var _a;\r\n    const atomState = ensureAtomState(atom);\r\n    if (isAtomStateInitialized(atomState)) {\r\n      if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\r\n        return atomState;\r\n      }\r\n      if (Array.from(atomState.d).every(\r\n        ([a, n]) => (\r\n          // Recursively, read the atom state of the dependency, and\r\n          // check if the atom epoch number is unchanged\r\n          readAtomState(a).n === n\r\n        )\r\n      )) {\r\n        return atomState;\r\n      }\r\n    }\r\n    atomState.d.clear();\r\n    let isSync = true;\r\n    const mountDependenciesIfAsync = () => {\r\n      if (mountedMap.has(atom)) {\r\n        mountDependencies(atom);\r\n        recomputeInvalidatedAtoms();\r\n        flushCallbacks();\r\n      }\r\n    };\r\n    const getter = (a) => {\r\n      var _a2;\r\n      if (isSelfAtom(atom, a)) {\r\n        const aState2 = ensureAtomState(a);\r\n        if (!isAtomStateInitialized(aState2)) {\r\n          if (hasInitialValue(a)) {\r\n            setAtomStateValueOrPromise(a, a.init, ensureAtomState);\r\n          } else {\r\n            throw new Error(\"no atom init\");\r\n          }\r\n        }\r\n        return returnAtomValue(aState2);\r\n      }\r\n      const aState = readAtomState(a);\r\n      try {\r\n        return returnAtomValue(aState);\r\n      } finally {\r\n        atomState.d.set(a, aState.n);\r\n        if (isPendingPromise(atomState.v)) {\r\n          addPendingPromiseToDependency(atom, atomState.v, aState);\r\n        }\r\n        (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\r\n        if (!isSync) {\r\n          mountDependenciesIfAsync();\r\n        }\r\n      }\r\n    };\r\n    let controller;\r\n    let setSelf;\r\n    const options = {\r\n      get signal() {\r\n        if (!controller) {\r\n          controller = new AbortController();\r\n        }\r\n        return controller.signal;\r\n      },\r\n      get setSelf() {\r\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\r\n          console.warn(\"setSelf function cannot be used with read-only atom\");\r\n        }\r\n        if (!setSelf && isActuallyWritableAtom(atom)) {\r\n          setSelf = (...args) => {\r\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\r\n              console.warn(\"setSelf function cannot be called in sync\");\r\n            }\r\n            if (!isSync) {\r\n              try {\r\n                return writeAtomState(atom, ...args);\r\n              } finally {\r\n                recomputeInvalidatedAtoms();\r\n                flushCallbacks();\r\n              }\r\n            }\r\n          };\r\n        }\r\n        return setSelf;\r\n      }\r\n    };\r\n    const prevEpochNumber = atomState.n;\r\n    try {\r\n      const valueOrPromise = atomRead(atom, getter, options);\r\n      setAtomStateValueOrPromise(atom, valueOrPromise, ensureAtomState);\r\n      if (isPromiseLike(valueOrPromise)) {\r\n        registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());\r\n        valueOrPromise.then(\r\n          mountDependenciesIfAsync,\r\n          mountDependenciesIfAsync\r\n        );\r\n      }\r\n      return atomState;\r\n    } catch (error) {\r\n      delete atomState.v;\r\n      atomState.e = error;\r\n      ++atomState.n;\r\n      return atomState;\r\n    } finally {\r\n      isSync = false;\r\n      if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\r\n        invalidatedAtoms.set(atom, atomState.n);\r\n        changedAtoms.add(atom);\r\n        (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, atom);\r\n      }\r\n    }\r\n  });\r\n  const invalidateDependents = buildingBlockFunctions[4] || ((atom) => {\r\n    const stack = [atom];\r\n    while (stack.length) {\r\n      const a = stack.pop();\r\n      const aState = ensureAtomState(a);\r\n      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\r\n        const dState = ensureAtomState(d);\r\n        invalidatedAtoms.set(d, dState.n);\r\n        stack.push(d);\r\n      }\r\n    }\r\n  });\r\n  const writeAtomState = buildingBlockFunctions[5] || ((atom, ...args) => {\r\n    let isSync = true;\r\n    const getter = (a) => returnAtomValue(readAtomState(a));\r\n    const setter = (a, ...args2) => {\r\n      var _a;\r\n      const aState = ensureAtomState(a);\r\n      try {\r\n        if (isSelfAtom(atom, a)) {\r\n          if (!hasInitialValue(a)) {\r\n            throw new Error(\"atom not writable\");\r\n          }\r\n          const prevEpochNumber = aState.n;\r\n          const v = args2[0];\r\n          setAtomStateValueOrPromise(a, v, ensureAtomState);\r\n          mountDependencies(a);\r\n          if (prevEpochNumber !== aState.n) {\r\n            changedAtoms.add(a);\r\n            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\r\n            invalidateDependents(a);\r\n          }\r\n          return void 0;\r\n        } else {\r\n          return writeAtomState(a, ...args2);\r\n        }\r\n      } finally {\r\n        if (!isSync) {\r\n          recomputeInvalidatedAtoms();\r\n          flushCallbacks();\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      return atomWrite(atom, getter, setter, ...args);\r\n    } finally {\r\n      isSync = false;\r\n    }\r\n  });\r\n  const mountDependencies = buildingBlockFunctions[6] || ((atom) => {\r\n    var _a;\r\n    const atomState = ensureAtomState(atom);\r\n    const mounted = mountedMap.get(atom);\r\n    if (mounted && !isPendingPromise(atomState.v)) {\r\n      for (const [a, n] of atomState.d) {\r\n        if (!mounted.d.has(a)) {\r\n          const aState = ensureAtomState(a);\r\n          const aMounted = mountAtom(a);\r\n          aMounted.t.add(atom);\r\n          mounted.d.add(a);\r\n          if (n !== aState.n) {\r\n            changedAtoms.add(a);\r\n            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\r\n            invalidateDependents(a);\r\n          }\r\n        }\r\n      }\r\n      for (const a of mounted.d || []) {\r\n        if (!atomState.d.has(a)) {\r\n          mounted.d.delete(a);\r\n          const aMounted = unmountAtom(a);\r\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\r\n        }\r\n      }\r\n    }\r\n  });\r\n  const mountAtom = buildingBlockFunctions[7] || ((atom) => {\r\n    var _a;\r\n    const atomState = ensureAtomState(atom);\r\n    let mounted = mountedMap.get(atom);\r\n    if (!mounted) {\r\n      readAtomState(atom);\r\n      for (const a of atomState.d.keys()) {\r\n        const aMounted = mountAtom(a);\r\n        aMounted.t.add(atom);\r\n      }\r\n      mounted = {\r\n        l: /* @__PURE__ */ new Set(),\r\n        d: new Set(atomState.d.keys()),\r\n        t: /* @__PURE__ */ new Set()\r\n      };\r\n      mountedMap.set(atom, mounted);\r\n      (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\r\n      if (isActuallyWritableAtom(atom)) {\r\n        const processOnMount = () => {\r\n          let isSync = true;\r\n          const setAtom = (...args) => {\r\n            try {\r\n              return writeAtomState(atom, ...args);\r\n            } finally {\r\n              if (!isSync) {\r\n                recomputeInvalidatedAtoms();\r\n                flushCallbacks();\r\n              }\r\n            }\r\n          };\r\n          try {\r\n            const onUnmount = atomOnMount(atom, setAtom);\r\n            if (onUnmount) {\r\n              mounted.u = () => {\r\n                isSync = true;\r\n                try {\r\n                  onUnmount();\r\n                } finally {\r\n                  isSync = false;\r\n                }\r\n              };\r\n            }\r\n          } finally {\r\n            isSync = false;\r\n          }\r\n        };\r\n        mountCallbacks.add(processOnMount);\r\n      }\r\n    }\r\n    return mounted;\r\n  });\r\n  const unmountAtom = buildingBlockFunctions[8] || ((atom) => {\r\n    var _a;\r\n    const atomState = ensureAtomState(atom);\r\n    let mounted = mountedMap.get(atom);\r\n    if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {\r\n      var _a2;\r\n      return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom);\r\n    })) {\r\n      if (mounted.u) {\r\n        unmountCallbacks.add(mounted.u);\r\n      }\r\n      mounted = void 0;\r\n      mountedMap.delete(atom);\r\n      (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom);\r\n      for (const a of atomState.d.keys()) {\r\n        const aMounted = unmountAtom(a);\r\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\r\n      }\r\n      return void 0;\r\n    }\r\n    return mounted;\r\n  });\r\n  const buildingBlocks = [\r\n    // store state\r\n    atomStateMap,\r\n    mountedMap,\r\n    invalidatedAtoms,\r\n    changedAtoms,\r\n    mountCallbacks,\r\n    unmountCallbacks,\r\n    storeHooks,\r\n    // atom interceptors\r\n    atomRead,\r\n    atomWrite,\r\n    atomOnInit,\r\n    atomOnMount,\r\n    // building-block functions\r\n    ensureAtomState,\r\n    flushCallbacks,\r\n    recomputeInvalidatedAtoms,\r\n    readAtomState,\r\n    invalidateDependents,\r\n    writeAtomState,\r\n    mountDependencies,\r\n    mountAtom,\r\n    unmountAtom\r\n  ];\r\n  const store = {\r\n    get: (atom) => returnAtomValue(readAtomState(atom)),\r\n    set: (atom, ...args) => {\r\n      try {\r\n        return writeAtomState(atom, ...args);\r\n      } finally {\r\n        recomputeInvalidatedAtoms();\r\n        flushCallbacks();\r\n      }\r\n    },\r\n    sub: (atom, listener) => {\r\n      const mounted = mountAtom(atom);\r\n      const listeners = mounted.l;\r\n      listeners.add(listener);\r\n      flushCallbacks();\r\n      return () => {\r\n        listeners.delete(listener);\r\n        unmountAtom(atom);\r\n        flushCallbacks();\r\n      };\r\n    }\r\n  };\r\n  Object.defineProperty(store, BUILDING_BLOCKS, { value: buildingBlocks });\r\n  return store;\r\n};\r\nconst INTERNAL_buildStoreRev1 = buildStore;\r\nconst INTERNAL_getBuildingBlocksRev1 = getBuildingBlocks;\r\nconst INTERNAL_initializeStoreHooks = initializeStoreHooks;\r\nconst INTERNAL_isSelfAtom = isSelfAtom;\r\nconst INTERNAL_hasInitialValue = hasInitialValue;\r\nconst INTERNAL_isActuallyWritableAtom = isActuallyWritableAtom;\r\nconst INTERNAL_isAtomStateInitialized = isAtomStateInitialized;\r\nconst INTERNAL_returnAtomValue = returnAtomValue;\r\nconst INTERNAL_promiseStateMap = promiseStateMap;\r\nconst INTERNAL_isPendingPromise = isPendingPromise;\r\nconst INTERNAL_abortPromise = abortPromise;\r\nconst INTERNAL_registerAbortHandler = registerAbortHandler;\r\nconst INTERNAL_isPromiseLike = isPromiseLike;\r\nconst INTERNAL_addPendingPromiseToDependency = addPendingPromiseToDependency;\r\nconst INTERNAL_setAtomStateValueOrPromise = setAtomStateValueOrPromise;\r\nconst INTERNAL_getMountedOrPendingDependents = getMountedOrPendingDependents;\r\n\r\nexport { INTERNAL_abortPromise, INTERNAL_addPendingPromiseToDependency, INTERNAL_buildStoreRev1, INTERNAL_getBuildingBlocksRev1, INTERNAL_getMountedOrPendingDependents, INTERNAL_hasInitialValue, INTERNAL_initializeStoreHooks, INTERNAL_isActuallyWritableAtom, INTERNAL_isAtomStateInitialized, INTERNAL_isPendingPromise, INTERNAL_isPromiseLike, INTERNAL_isSelfAtom, INTERNAL_promiseStateMap, INTERNAL_registerAbortHandler, INTERNAL_returnAtomValue, INTERNAL_setAtomStateValueOrPromise };\r\n", "import { INTERNAL_buildStoreRev1, INTERNAL_initializeStoreHooks } from 'jotai/vanilla/internals';\r\n\r\nlet keyCount = 0;\r\nfunction atom(read, write) {\r\n  const key = `atom${++keyCount}`;\r\n  const config = {\r\n    toString() {\r\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\r\n    }\r\n  };\r\n  if (typeof read === \"function\") {\r\n    config.read = read;\r\n  } else {\r\n    config.init = read;\r\n    config.read = defaultRead;\r\n    config.write = defaultWrite;\r\n  }\r\n  if (write) {\r\n    config.write = write;\r\n  }\r\n  return config;\r\n}\r\nfunction defaultRead(get) {\r\n  return get(this);\r\n}\r\nfunction defaultWrite(get, set, arg) {\r\n  return set(\r\n    this,\r\n    typeof arg === \"function\" ? arg(get(this)) : arg\r\n  );\r\n}\r\n\r\nconst createDevStoreRev4 = () => {\r\n  let inRestoreAtom = 0;\r\n  const storeHooks = INTERNAL_initializeStoreHooks({});\r\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\r\n  const mountedAtoms = /* @__PURE__ */ new WeakMap();\r\n  const store = INTERNAL_buildStoreRev1(\r\n    atomStateMap,\r\n    mountedAtoms,\r\n    void 0,\r\n    void 0,\r\n    void 0,\r\n    void 0,\r\n    storeHooks,\r\n    void 0,\r\n    (atom, get, set, ...args) => {\r\n      if (inRestoreAtom) {\r\n        return set(atom, ...args);\r\n      }\r\n      return atom.write(get, set, ...args);\r\n    }\r\n  );\r\n  const debugMountedAtoms = /* @__PURE__ */ new Set();\r\n  storeHooks.m.add(void 0, (atom) => {\r\n    debugMountedAtoms.add(atom);\r\n    const atomState = atomStateMap.get(atom);\r\n    atomState.m = mountedAtoms.get(atom);\r\n  });\r\n  storeHooks.u.add(void 0, (atom) => {\r\n    debugMountedAtoms.delete(atom);\r\n    const atomState = atomStateMap.get(atom);\r\n    delete atomState.m;\r\n  });\r\n  const devStore = {\r\n    // store dev methods (these are tentative and subject to change without notice)\r\n    dev4_get_internal_weak_map: () => {\r\n      console.log(\"Deprecated: Use devstore from the devtools library\");\r\n      return atomStateMap;\r\n    },\r\n    dev4_get_mounted_atoms: () => debugMountedAtoms,\r\n    dev4_restore_atoms: (values) => {\r\n      const restoreAtom = {\r\n        read: () => null,\r\n        write: (_get, set) => {\r\n          ++inRestoreAtom;\r\n          try {\r\n            for (const [atom, value] of values) {\r\n              if (\"init\" in atom) {\r\n                set(atom, value);\r\n              }\r\n            }\r\n          } finally {\r\n            --inRestoreAtom;\r\n          }\r\n        }\r\n      };\r\n      store.set(restoreAtom);\r\n    }\r\n  };\r\n  return Object.assign(store, devStore);\r\n};\r\nlet overiddenCreateStore;\r\nfunction INTERNAL_overrideCreateStore(fn) {\r\n  overiddenCreateStore = fn(overiddenCreateStore);\r\n}\r\nfunction createStore() {\r\n  if (overiddenCreateStore) {\r\n    return overiddenCreateStore();\r\n  }\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n    return createDevStoreRev4();\r\n  }\r\n  return INTERNAL_buildStoreRev1();\r\n}\r\nlet defaultStore;\r\nfunction getDefaultStore() {\r\n  if (!defaultStore) {\r\n    defaultStore = createStore();\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\r\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\r\n        console.warn(\r\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return defaultStore;\r\n}\r\n\r\nexport { INTERNAL_overrideCreateStore, atom, createStore, getDefaultStore };\r\n", "'use client';\r\nimport React, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\r\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\r\nimport { INTERNAL_registerAbortHandler } from 'jotai/vanilla/internals';\r\n\r\nconst StoreContext = createContext(\r\n  void 0\r\n);\r\nfunction useStore(options) {\r\n  const store = useContext(StoreContext);\r\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\r\n}\r\nfunction Provider({\r\n  children,\r\n  store\r\n}) {\r\n  const storeRef = useRef(void 0);\r\n  if (!store && !storeRef.current) {\r\n    storeRef.current = createStore();\r\n  }\r\n  return createElement(\r\n    StoreContext.Provider,\r\n    {\r\n      value: store || storeRef.current\r\n    },\r\n    children\r\n  );\r\n}\r\n\r\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\r\nconst attachPromiseStatus = (promise) => {\r\n  if (!promise.status) {\r\n    promise.status = \"pending\";\r\n    promise.then(\r\n      (v) => {\r\n        promise.status = \"fulfilled\";\r\n        promise.value = v;\r\n      },\r\n      (e) => {\r\n        promise.status = \"rejected\";\r\n        promise.reason = e;\r\n      }\r\n    );\r\n  }\r\n};\r\nconst use = React.use || // A shim for older React versions\r\n((promise) => {\r\n  if (promise.status === \"pending\") {\r\n    throw promise;\r\n  } else if (promise.status === \"fulfilled\") {\r\n    return promise.value;\r\n  } else if (promise.status === \"rejected\") {\r\n    throw promise.reason;\r\n  } else {\r\n    attachPromiseStatus(promise);\r\n    throw promise;\r\n  }\r\n});\r\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\r\nconst createContinuablePromise = (promise, getValue) => {\r\n  let continuablePromise = continuablePromiseMap.get(promise);\r\n  if (!continuablePromise) {\r\n    continuablePromise = new Promise((resolve, reject) => {\r\n      let curr = promise;\r\n      const onFulfilled = (me) => (v) => {\r\n        if (curr === me) {\r\n          resolve(v);\r\n        }\r\n      };\r\n      const onRejected = (me) => (e) => {\r\n        if (curr === me) {\r\n          reject(e);\r\n        }\r\n      };\r\n      const onAbort = () => {\r\n        try {\r\n          const nextValue = getValue();\r\n          if (isPromiseLike(nextValue)) {\r\n            continuablePromiseMap.set(nextValue, continuablePromise);\r\n            curr = nextValue;\r\n            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\r\n            INTERNAL_registerAbortHandler(nextValue, onAbort);\r\n          } else {\r\n            resolve(nextValue);\r\n          }\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      };\r\n      promise.then(onFulfilled(promise), onRejected(promise));\r\n      INTERNAL_registerAbortHandler(promise, onAbort);\r\n    });\r\n    continuablePromiseMap.set(promise, continuablePromise);\r\n  }\r\n  return continuablePromise;\r\n};\r\nfunction useAtomValue(atom, options) {\r\n  const { delay, unstable_promiseStatus: promiseStatus = !React.use } = options || {};\r\n  const store = useStore(options);\r\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\r\n    (prev) => {\r\n      const nextValue = store.get(atom);\r\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\r\n        return prev;\r\n      }\r\n      return [nextValue, store, atom];\r\n    },\r\n    void 0,\r\n    () => [store.get(atom), store, atom]\r\n  );\r\n  let value = valueFromReducer;\r\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\r\n    rerender();\r\n    value = store.get(atom);\r\n  }\r\n  useEffect(() => {\r\n    const unsub = store.sub(atom, () => {\r\n      if (promiseStatus) {\r\n        try {\r\n          const value2 = store.get(atom);\r\n          if (isPromiseLike(value2)) {\r\n            attachPromiseStatus(\r\n              createContinuablePromise(value2, () => store.get(atom))\r\n            );\r\n          }\r\n        } catch (e) {\r\n        }\r\n      }\r\n      if (typeof delay === \"number\") {\r\n        setTimeout(rerender, delay);\r\n        return;\r\n      }\r\n      rerender();\r\n    });\r\n    rerender();\r\n    return unsub;\r\n  }, [store, atom, delay, promiseStatus]);\r\n  useDebugValue(value);\r\n  if (isPromiseLike(value)) {\r\n    const promise = createContinuablePromise(value, () => store.get(atom));\r\n    if (promiseStatus) {\r\n      attachPromiseStatus(promise);\r\n    }\r\n    return use(promise);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction useSetAtom(atom, options) {\r\n  const store = useStore(options);\r\n  const setAtom = useCallback(\r\n    (...args) => {\r\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\r\n        throw new Error(\"not writable atom\");\r\n      }\r\n      return store.set(atom, ...args);\r\n    },\r\n    [store, atom]\r\n  );\r\n  return setAtom;\r\n}\r\n\r\nfunction useAtom(atom, options) {\r\n  return [\r\n    useAtomValue(atom, options),\r\n    // We do wrong type assertion here, which results in throwing an error.\r\n    useSetAtom(atom, options)\r\n  ];\r\n}\r\n\r\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\r\n"],
  "mappings": "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",
  "names": ["atom", "atom", "atom", "isPromiseLike", "React", "atom"]
}
